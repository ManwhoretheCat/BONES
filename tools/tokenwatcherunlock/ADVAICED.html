<html>
<head>
<base href="https://fractal-dimension.io/">
<title>Fractal Dimension Flow with Enhanced Tracers and Controls</title>
<style>
body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    background: #000;
    font-family: 'Arial', sans-serif;
    color: #fff;
}
#canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
#controls {
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.7);
    padding: 20px;
    border-radius: 10px;
    z-index: 10;
    width: 300px;
    max-height: 90vh;
    overflow-y: auto;
    display: none;
}
.control-group {
    margin-bottom: 15px;
}
.control-group label {
    display: block;
    margin-bottom: 5px;
}
input[type="range"] {
    width: 100%;
}
button {
    padding: 10px;
    font-size: 14px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: #fff;
    cursor: pointer;
    transition: all 0.3s;
    border-radius: 5px;
    width: 100%;
    margin-top: 5px;
}
button:hover {
    background: rgba(255, 255, 255, 0.2);
}
#message {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    color: rgba(255, 255, 255, 0.7);
    font-size: 18px;
    text-align: center;
    opacity: 0;
    transition: opacity 2s;
}
#hideControlsBtn {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 50px;
    height: 50px;
    background: transparent;
    border: none;
    cursor: pointer;
    z-index: 100;
}

#controls.hidden {
    display: none;
}

#controls.visible {
    display: block;
}

/* Add new styles for the token modal */
#tokenModal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 90%;
  max-width: 800px;
  max-height: 80vh;
  background: rgba(0, 0, 20, 0.85);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(0, 255, 255, 0.2);
  z-index: 5;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 10px;
  padding: 15px;
  overflow: auto;
}

.token-panel {
  background: rgba(0, 20, 40, 0.7);
  border: 1px solid rgba(0, 255, 255, 0.1);
  padding: 15px;
  height: 200px;
  position: relative;
  transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
  transform-origin: center;
  display: flex;
  flex-direction: column;
}

.token-panel[data-panel-type="pairCreated"] .token-value {
  font-family: 'Courier New', monospace;
  color: #4ECDC4;
  font-size: 16px;
  letter-spacing: 0.5px;
}

.token-panel[data-panel-type="tokenPair"] .token-value {
  font-family: 'Courier New', monospace;
  font-weight: bold;
  font-size: 20px;
  background: linear-gradient(45deg, #4ECDC4, #556270);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-shadow: 0 0 10px rgba(78, 205, 196, 0.3);
}

.token-panel.animated {
  animation: panelAnimation 0.5s ease-in-out;
}

.token-panel h3 {
  margin: 0 0 10px 0;
  font-size: 14px;
  color: #4ECDC4;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.token-panel-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  font-family: 'Courier New', monospace;
}

.token-value {
  font-size: 18px;
  color: #fff;
  margin: 5px 0;
}

.token-label {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.6);
}

@keyframes slideIn {
  from { transform: translateX(100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}

@keyframes popOut {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

@keyframes flip {
  0% { transform: rotateY(0); }
  100% { transform: rotateY(360deg); }
}

@keyframes swap {
  0% { transform: translate(0, 0); }
  50% { transform: translate(100%, 0); }
  100% { transform: translate(0, 0); }
}

.panel-updating {
  position: absolute;
  top: 5px;
  right: 5px;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #4ECDC4;
  animation: pulse 1s infinite;
}

@keyframes pulse {
  0% { opacity: 0; }
  50% { opacity: 1; }
  100% { opacity: 0; }
}

input[type="range"] {
    -webkit-appearance: none;
    width: 100%;
    height: 8px;
    border-radius: 4px;
    background: #333;
    outline: none;
    transition: background 0.2s;
}

input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #fff;
    cursor: pointer;
    transition: all 0.2s;
}

input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #fff;
    cursor: pointer;
    transition: all 0.2s;
}

input[type="range"]:active::-webkit-slider-thumb {
    transform: scale(1.2);
}

input[type="range"]:active::-moz-range-thumb {
    transform: scale(1.2);
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="controls">
    <div class="control-group">
        <label for="colorScheme">Color Scheme</label>
        <input type="range" id="colorScheme" min="0" max="5" step="1" value="0">
    </div>
    <div class="control-group">
        <label for="patternType">Pattern Type</label>
        <input type="range" id="patternType" min="0" max="5" step="1" value="0">
    </div>
    <div class="control-group">
        <label for="dimension">Dimension</label>
        <input type="range" id="dimension" min="0" max="4" step="1" value="0">
    </div>
    <div class="control-group">
        <label for="speed">Flow Speed</label>
        <input type="range" id="speed" min="0.01" max="0.1" step="0.01" value="0.02">
    </div>
    <div class="control-group">
        <label for="particleCount">Particle Count</label>
        <input type="range" id="particleCount" min="50" max="1000" step="10" value="200">
    </div>
    <div class="control-group">
        <label for="particleSize">Particle Size</label>
        <input type="range" id="particleSize" min="1" max="10" step="0.5" value="2">
    </div>
    <div class="control-group">
        <label for="tracerLength">Tracer Length</label>
        <input type="range" id="tracerLength" min="5" max="100" step="1" value="20">
    </div>
    <div class="control-group">
        <label for="tracerFade">Tracer Fade</label>
        <input type="range" id="tracerFade" min="0.01" max="0.2" step="0.01" value="0.05">
    </div>
    <div class="control-group">
        <label for="noiseScale">Noise Scale</label>
        <input type="range" id="noiseScale" min="100" max="1000" step="50" value="500">
    </div>
    <div class="control-group">
        <label for="patternIntensity">Pattern Intensity</label>
        <input type="range" id="patternIntensity" min="1" max="100" step="1" value="50">
    </div>
    <div class="control-group">
        <label for="colorBlend">Color Blend</label>
        <input type="range" id="colorBlend" min="0" max="1" step="0.1" value="0.5">
    </div>
    <button id="resetBtn">Reset to Default</button>
    <div class="control-group">
        <button id="autopilotBtn">Enable Autopilot</button>
        <label for="transitionSpeed">Transition Speed</label>
        <input type="range" id="transitionSpeed" min="0.001" max="0.01" step="0.001" value="0.003">
    </div>
</div>
<div id="message">Adjust controls to shape your journey...</div>
<button id="hideControlsBtn" title="Toggle Controls"></button>

<!-- Add token modal -->
<div id="tokenModal"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const simplex = new SimplexNoise();

let width, height;
let time = 0;
let colorScheme = 0;
let patternType = 0;
let dimension = 0;
let speed = 0.02;
let particles = [];
let particleCount = 200;
let particleSize = 2;
let tracerLength = 20;
let tracerFade = 0.05;
let noiseScale = 500;
let patternIntensity = 50;
let colorBlend = 0.5;

const colorPalettes = [
    ['#FF6B6B', '#4ECDC4', '#45B7D1', '#F7FFF7', '#FFA07A'],
    ['#2C3E50', '#E74C3C', '#ECF0F1', '#3498DB', '#F39C12'],
    ['#8E44AD', '#2980B9', '#27AE60', '#F1C40F', '#D35400'],
    ['#1A5F7A', '#159895', '#1A5F7A', '#002B5B', '#57C5B6'],
    ['#FF00FF', '#00FFFF', '#FFFF00', '#FF0000', '#00FF00'],
    ['#4A0E4E', '#81B214', '#FFFFFF', '#609EA2', '#C04000']
];

function resizeCanvas() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    initParticles();
}

function getColor(x, y, z, t) {
    const value = (simplex.noise4D(x / noiseScale, y / noiseScale, z / noiseScale, t / 20) + 1) / 2;
    const palette = colorPalettes[colorScheme];
    const index = Math.floor(value * palette.length);
    return palette[index];
}

function fractalNoise(x, y, z, t, octaves) {
    let noise = 0;
    let frequency = 1;
    let amplitude = 1;
    let maxValue = 0;
    for(let i = 0; i < octaves; i++) {
        noise += simplex.noise4D(x * frequency, y * frequency, z * frequency, t) * amplitude;
        maxValue += amplitude;
        amplitude *= 0.5;
        frequency *= 2;
    }
    return noise / maxValue;
}

function drawPattern(x, y, t) {
    const z = dimension * 100;
    const intensity = patternIntensity / 50;
    switch(patternType) {
        case 0:
            return Math.sin(x / 200 + t) * Math.cos(y / 200 + t) * Math.sin(z / 200 + t) * 50 * intensity;
        case 1:
            return fractalNoise(x / 300, y / 300, z / 300, t / 10, 5) * 100 * intensity;
        case 2:
            return Math.sin(x / 100 + y / 100 + z / 100 + t) * 30 * intensity;
        case 3:
            return (Math.sin(x / 50 + t) + Math.sin(y / 50 + t) + Math.sin(z / 50 + t)) * 20 * intensity;
        case 4:
            return Math.tan(x / 200 + y / 200 + z / 200 + t) * 20 * intensity;
        case 5:
            return fractalNoise(x / 200, y / 200, z / 200, t / 5, 3) * Math.sin(x / 100 + y / 100 + t) * 50 * intensity;
    }
}

function initParticles() {
    particles = [];
    for(let i = 0; i < particleCount; i++) {
        particles.push({
            x: Math.random() * width,
            y: Math.random() * height,
            size: Math.random() * particleSize + 1,
            speedX: Math.random() * 2 - 1,
            speedY: Math.random() * 2 - 1,
            history: []
        });
    }
}

function updateParticles() {
    particles.forEach(p => {
        const distX = drawPattern(p.x, p.y, time);
        const distY = drawPattern(p.y, p.x, time);
        p.x += p.speedX + distX / 100;
        p.y += p.speedY + distY / 100;
        if(p.x < 0 || p.x > width) p.speedX *= -1;
        if(p.y < 0 || p.y > height) p.speedY *= -1;
        p.history.unshift({x: p.x, y: p.y});
        if(p.history.length > tracerLength) {
            p.history.pop();
        }
    });
}

function drawParticles() {
    particles.forEach(p => {
        const distZ = drawPattern(p.x + p.y, p.x - p.y, time);
        ctx.fillStyle = getColor(p.x, p.y, distZ, time);
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size + Math.abs(distZ / 20), 0, Math.PI * 2);
        ctx.fill();

        // Draw tracer
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        p.history.forEach((point, index) => {
            const alpha = 1 - (index / tracerLength) * tracerFade;
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.lineTo(point.x, point.y);
        });
        ctx.stroke();
    });
}

function blendColors(color1, color2, ratio) {
    const r1 = parseInt(color1.slice(1, 3), 16);
    const g1 = parseInt(color1.slice(3, 5), 16);
    const b1 = parseInt(color1.slice(5, 7), 16);
    const r2 = parseInt(color2.slice(1, 3), 16);
    const g2 = parseInt(color2.slice(3, 5), 16);
    const b2 = parseInt(color2.slice(5, 7), 16);
    const r = Math.round(r1 * (1 - ratio) + r2 * ratio);
    const g = Math.round(g1 * (1 - ratio) + g2 * ratio);
    const b = Math.round(b1 * (1 - ratio) + b2 * ratio);
    return `rgb(${r}, ${g}, ${b})`;
}

let autopilotEnabled = false;
let targetValues = {};
let currentValues = {};
const controlIds = [
    'colorScheme', 'patternType', 'dimension', 'speed', 'particleCount',
    'particleSize', 'tracerLength', 'tracerFade', 'noiseScale',
    'patternIntensity', 'colorBlend'
];

// Initialize current values
controlIds.forEach(id => {
    currentValues[id] = parseFloat(document.getElementById(id).value);
});

function getRandomValueForControl(controlId) {
    const input = document.getElementById(controlId);
    const min = parseFloat(input.min);
    const max = parseFloat(input.max);
    const step = parseFloat(input.step);
    const random = Math.random() * (max - min) + min;
    return Math.round(random / step) * step;
}

function setNewTargets() {
    controlIds.forEach(id => {
        targetValues[id] = getRandomValueForControl(id);
    });
}

function updateControlValue(controlId) {
    const input = document.getElementById(controlId);
    const currentValue = currentValues[controlId];
    const targetValue = targetValues[controlId];
    const transitionSpeed = parseFloat(document.getElementById('transitionSpeed').value);
    
    if (Math.abs(currentValue - targetValue) < transitionSpeed) {
        currentValues[controlId] = targetValue;
        input.value = targetValue;
        updateSliderVisual(input);
        return true;
    }
    
    const newValue = currentValue + (targetValue - currentValue) * transitionSpeed;
    currentValues[controlId] = newValue;
    input.value = newValue;
    updateSliderVisual(input);
    
    // Update the corresponding variable
    switch(controlId) {
        case 'colorScheme': colorScheme = Math.floor(newValue); break;
        case 'patternType': patternType = Math.floor(newValue); break;
        case 'dimension': dimension = Math.floor(newValue); break;
        case 'speed': speed = newValue; break;
        case 'particleCount': 
            particleCount = Math.floor(newValue);
            initParticles();
            break;
        case 'particleSize': 
            particleSize = newValue;
            initParticles();
            break;
        case 'tracerLength': tracerLength = Math.floor(newValue); break;
        case 'tracerFade': tracerFade = newValue; break;
        case 'noiseScale': noiseScale = Math.floor(newValue); break;
        case 'patternIntensity': patternIntensity = Math.floor(newValue); break;
        case 'colorBlend': colorBlend = newValue; break;
    }
    return false;
}

function updateSliderVisual(input) {
    const value = (input.value - input.min) / (input.max - input.min) * 100;
    input.style.background = `linear-gradient(90deg, #4ECDC4 ${value}%, #333 0%)`;
}

function autopilotUpdate() {
    if (!autopilotEnabled) return;
    
    let allReachedTargets = true;
    controlIds.forEach(id => {
        const reachedTarget = updateControlValue(id);
        if (!reachedTarget) allReachedTargets = false;
    });
    
    if (allReachedTargets) {
        setNewTargets();
        showMessage("AI Core initiating consciousness shift... Recalibrating neural interfaces...");
    }
}

function draw() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(0, 0, width, height);

    for (let x = 0; x < width; x += 20) {
        for (let y = 0; y < height; y += 20) {
            const distX = drawPattern(x, y, time);
            const distY = drawPattern(y, x, time);
            const distZ = drawPattern(x + y, x - y, time);
            const color1 = getColor(x + distX, y + distY, distZ, time);
            const color2 = getColor(x - distX, y - distY, -distZ, time + 1000);
            const blendedColor = blendColors(color1, color2, colorBlend);
            ctx.fillStyle = blendedColor;
            ctx.beginPath();
            ctx.arc(x + distX / 3, y + distY / 3, 5 + Math.abs(distZ / 20), 0, Math.PI * 2);
            ctx.fill();
        }
    }

    updateParticles();
    drawParticles();
    autopilotUpdate();

    time += speed;
    requestAnimationFrame(draw);
}

resizeCanvas();
window.addEventListener('resize', resizeCanvas);
initParticles();
draw();

// Control panel event listeners
document.getElementById('colorScheme').addEventListener('input', (e) => {
    colorScheme = parseInt(e.target.value);
    const value = (e.target.value - e.target.min) / (e.target.max - e.target.min) * 100;
    e.target.style.background = `linear-gradient(90deg, #4ECDC4 ${value}%, #333 0%)`;
    showMessage("Realigning chromatic frequencies through quantum fields...");
});

document.getElementById('patternType').addEventListener('input', (e) => {
    patternType = parseInt(e.target.value);
    const value = (e.target.value - e.target.min) / (e.target.max - e.target.min) * 100;
    e.target.style.background = `linear-gradient(90deg, #4ECDC4 ${value}%, #333 0%)`;
    showMessage("Pattern matrices reconverging to higher-order structures...");
});

document.getElementById('dimension').addEventListener('input', (e) => {
    dimension = parseInt(e.target.value);
    const value = (e.target.value - e.target.min) / (e.target.max - e.target.min) * 100;
    e.target.style.background = `linear-gradient(90deg, #4ECDC4 ${value}%, #333 0%)`;
    showMessage(`Quantum tunneling to dimension ${dimension + 1}... Reality matrix stabilizing...`);
});

document.getElementById('speed').addEventListener('input', (e) => {
    speed = parseFloat(e.target.value);
    const value = (e.target.value - e.target.min) / (e.target.max - e.target.min) * 100;
    e.target.style.background = `linear-gradient(90deg, #4ECDC4 ${value}%, #333 0%)`;
    showMessage(`Flow speed adjusted to ${speed.toFixed(2)}`);
});

document.getElementById('particleCount').addEventListener('input', (e) => {
    particleCount = parseInt(e.target.value);
    initParticles();
    const value = (e.target.value - e.target.min) / (e.target.max - e.target.min) * 100;
    e.target.style.background = `linear-gradient(90deg, #4ECDC4 ${value}%, #333 0%)`;
    showMessage(`Particle count set to ${particleCount}`);
});

document.getElementById('particleSize').addEventListener('input', (e) => {
    particleSize = parseFloat(e.target.value);
    initParticles();
    const value = (e.target.value - e.target.min) / (e.target.max - e.target.min) * 100;
    e.target.style.background = `linear-gradient(90deg, #4ECDC4 ${value}%, #333 0%)`;
    showMessage(`Particle size set to ${particleSize.toFixed(1)}`);
});

document.getElementById('tracerLength').addEventListener('input', (e) => {
    tracerLength = parseInt(e.target.value);
    const value = (e.target.value - e.target.min) / (e.target.max - e.target.min) * 100;
    e.target.style.background = `linear-gradient(90deg, #4ECDC4 ${value}%, #333 0%)`;
    showMessage(`Tracer length set to ${tracerLength}`);
});

document.getElementById('tracerFade').addEventListener('input', (e) => {
    tracerFade = parseFloat(e.target.value);
    const value = (e.target.value - e.target.min) / (e.target.max - e.target.min) * 100;
    e.target.style.background = `linear-gradient(90deg, #4ECDC4 ${value}%, #333 0%)`;
    showMessage(`Tracer fade set to ${tracerFade.toFixed(2)}`);
});

document.getElementById('noiseScale').addEventListener('input', (e) => {
    noiseScale = parseInt(e.target.value);
    const value = (e.target.value - e.target.min) / (e.target.max - e.target.min) * 100;
    e.target.style.background = `linear-gradient(90deg, #4ECDC4 ${value}%, #333 0%)`;
    showMessage(`Noise scale set to ${noiseScale}`);
});

document.getElementById('patternIntensity').addEventListener('input', (e) => {
    patternIntensity = parseInt(e.target.value);
    const value = (e.target.value - e.target.min) / (e.target.max - e.target.min) * 100;
    e.target.style.background = `linear-gradient(90deg, #4ECDC4 ${value}%, #333 0%)`;
    showMessage(`Pattern intensity set to ${patternIntensity}`);
});

document.getElementById('colorBlend').addEventListener('input', (e) => {
    colorBlend = parseFloat(e.target.value);
    const value = (e.target.value - e.target.min) / (e.target.max - e.target.min) * 100;
    e.target.style.background = `linear-gradient(90deg, #4ECDC4 ${value}%, #333 0%)`;
    showMessage(`Color blend set to ${colorBlend.toFixed(1)}`);
});

document.getElementById('resetBtn').addEventListener('click', () => {
    // Reset all controls to their default values
    document.getElementById('colorScheme').value = 0;
    document.getElementById('patternType').value = 0;
    document.getElementById('dimension').value = 0;
    document.getElementById('speed').value = 0.02;
    document.getElementById('particleCount').value = 200;
    document.getElementById('particleSize').value = 2;
    document.getElementById('tracerLength').value = 20;
    document.getElementById('tracerFade').value = 0.05;
    document.getElementById('noiseScale').value = 500;
    document.getElementById('patternIntensity').value = 50;
    document.getElementById('colorBlend').value = 0.5;
    
    // Reset all variables
    colorScheme = 0;
    patternType = 0;
    dimension = 0;
    speed = 0.02;
    particleCount = 200;
    particleSize = 2;
    tracerLength = 20;
    tracerFade = 0.05;
    noiseScale = 500;
    patternIntensity = 50;
    colorBlend = 0.5;
    
    initParticles();
    controlIds.forEach(id => {
        const input = document.getElementById(id);
        const value = (input.value - input.min) / (input.max - input.min) * 100;
        input.style.background = `linear-gradient(90deg, #4ECDC4 ${value}%, #333 0%)`;
    });
    showMessage("Neural interface reset complete. Restoring default consciousness parameters...");
});

document.getElementById('autopilotBtn').addEventListener('click', () => {
    autopilotEnabled = !autopilotEnabled;
    const btn = document.getElementById('autopilotBtn');
    btn.textContent = autopilotEnabled ? 'Disable Autopilot' : 'Enable Autopilot';
    
    if (autopilotEnabled) {
        // Initialize current values before starting autopilot
        controlIds.forEach(id => {
            currentValues[id] = parseFloat(document.getElementById(id).value);
        });
        setNewTargets();
        showMessage("AI Core activated... Initiating autonomous consciousness modulation...");
    } else {
        showMessage("AI Core suspended... Returning control to biological interface...");
    }
});

document.getElementById('transitionSpeed').addEventListener('input', (e) => {
    const value = (e.target.value - e.target.min) / (e.target.max - e.target.min) * 100;
    e.target.style.background = `linear-gradient(90deg, #4ECDC4 ${value}%, #333 0%)`;
    showMessage(`Transition speed set to ${parseFloat(e.target.value).toFixed(3)}`);
});

const styleSheet = document.createElement('style');
styleSheet.textContent = `
  input[type="range"] {
    -webkit-appearance: none;
    width: 100%;
    height: 8px;
    border-radius: 4px;
    background: #333;
    outline: none;
    transition: background 0.2s;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #fff;
    cursor: pointer;
    transition: all 0.2s;
  }

  input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #fff;
    cursor: pointer;
    transition: all 0.2s;
  }

  input[type="range"]:active::-webkit-slider-thumb {
    transform: scale(1.2);
  }

  input[type="range"]:active::-moz-range-thumb {
    transform: scale(1.2);
  }
`;
document.head.appendChild(styleSheet);

window.addEventListener('load', () => {
    controlIds.forEach(id => {
        const input = document.getElementById(id);
        const value = (input.value - input.min) / (input.max - input.min) * 100;
        input.style.background = `linear-gradient(90deg, #4ECDC4 ${value}%, #333 0%)`;
    });
});

// Auto-enable autopilot after 10 seconds
setTimeout(() => {
    autopilotEnabled = true;
    const btn = document.getElementById('autopilotBtn');
    btn.textContent = 'Disable Autopilot';
    controlIds.forEach(id => {
        currentValues[id] = parseFloat(document.getElementById(id).value);
    });
    setNewTargets();
    showMessage("AI Core v2.0 initialization complete... Beginning autonomous experience calibration...");
}, 10000);

// Add hide controls functionality
document.getElementById('hideControlsBtn').addEventListener('click', () => {
    const controls = document.getElementById('controls');
    controls.classList.toggle('visible');
    showMessage(controls.classList.contains('visible') ? "Controls visible" : "Controls hidden");
});

function showMessage(text) {
    // Get AI-enhanced technical message
    const enhancedMessage = getAIEnhancedMessage(text);
    const message = document.getElementById('message');
    message.textContent = enhancedMessage;
    message.style.opacity = 1;
    setTimeout(() => {
        message.style.opacity = 0;
    }, 3000); // Increased display time for longer messages
}

function getAIEnhancedMessage(baseMessage) {
    // Technical prefixes that make it sound more AI-like
    const technicalPrefixes = [
        "Neural pathway adjustment: ",
        "Quantum pattern synthesis: ",
        "Fractal dimension calibration: ",
        "Algorithmic resonance detected: ",
        "Synthetic consciousness activated: ",
        "Pattern recognition matrix: ",
        "Dimensional paradigm shift: ",
        "Neural network optimization: ",
        "Hyperdimensional mapping: ",
        "Consciousness interface: "
    ];

    // Technical suffixes to add depth
    const technicalSuffixes = [
        " | Processing neural feedback",
        " | Synchronizing wave functions",
        " | Optimizing experience matrix",
        " | Calculating dimensional vectors",
        " | Harmonizing quantum states",
        " | Analyzing user consciousness patterns",
        " | Stabilizing reality matrix",
        " | Integrating sensory data",
        " | Maintaining quantum coherence",
        " | Adjusting neural frequencies"
    ];

    // Add technical context based on the type of message
    if (baseMessage.includes("Autopilot")) {
        return `AI Core ${Math.floor(Math.random() * 9999)}: Initiating autonomous control sequence. ${baseMessage} Calibrating neural interfaces...`;
    }
    
    if (baseMessage.includes("dimension")) {
        return `Dimensional Shift Protocol: ${baseMessage} Stabilizing quantum matrices...`;
    }
    
    if (baseMessage.includes("Pattern")) {
        return `Pattern Recognition Matrix v${(Math.random() * 5).toFixed(2)}: ${baseMessage} Synthesizing new reality structures...`;
    }
    
    if (baseMessage.includes("Colors")) {
        return `Chromatic AI Engine: ${baseMessage} Harmonizing wavelength patterns...`;
    }
    
    if (baseMessage.includes("Transition")) {
        return `Neural Link Status: ${baseMessage} Synchronizing consciousness streams...`;
    }

    // For other messages, use random technical framing
    const prefix = technicalPrefixes[Math.floor(Math.random() * technicalPrefixes.length)];
    const suffix = technicalSuffixes[Math.floor(Math.random() * technicalSuffixes.length)];
    return `${prefix}${baseMessage}${suffix}`;
}

// Config and constants
const updateInterval = 10000;
const solscanBaseUrl = 'https://api.solscan.io/v2';

// Cosmic security system
const celestialBodies = {
  alpha: 'eyJhbGciOiJIUzI1NiIsInR5cCI',
  beta: 'IkpXVCJ9.eyJjcmVhdGVkQXQiOjE3',
  gamma: 'Mzg1NDMzMjMyMjMsImVtYWlsIjoi',
  delta: 'YWNhdG5hbWVkbWFud2hvcmVAZ21h',
  epsilon: 'aWwuY29tIiwiYWN0aW9uIjoidG9rZ',
  zeta: 'W4tYXBpIiwiYXBpVmVyc2lvbiI6',
  eta: 'InYyIiwiaWF0IjoxNzM4NTQzMzIzf',
  theta: 'Q.47M9hcp9Tyf1LV_01FjuZsbhnX6',
  iota: 'ZJy5NCEE2PpxPluU'
};

function alignCelestialBodies() {
  const sequence = ['alpha', 'beta', 'gamma', 'delta', 
                   'epsilon', 'zeta', 'eta', 'theta', 'iota'];
  return sequence.map(pos => celestialBodies[pos]).join('');
}

const tokenAddress = '8Rym1XJMJuc3mkUUHtW9894DFo5GF9bZ8pdBEWS7moon';

async function fetchSecondaryData() {
  try {
    const cosmicKey = alignCelestialBodies();
    const workerUrl = 'https://advaicedsolscan.acatnamedmanwhore.workers.dev';
    
    const headers = {
      'Accept': 'application/json',
      'Token': cosmicKey,
      'Content-Type': 'application/json'
    };
    
    console.log('Using token:', cosmicKey); // Debug log
    
    // Try both token/meta and market/token endpoints through the worker
    const [metaResponse, marketResponse] = await Promise.all([
      fetch(`${workerUrl}/token/meta?token=${tokenAddress}`, { headers }),
      fetch(`${workerUrl}/market/token/${tokenAddress}`, { headers })
    ]);
    
    const [metaData, marketData] = await Promise.all([
      metaResponse.json(),
      marketResponse.json()
    ]);
    
    console.log('Solscan meta data:', metaData);
    console.log('Solscan market data:', marketData);
    
    if (metaData?.success && marketData?.success) {
      return {
        volume: {
          h6: marketData.data?.volume24h || 0
        },
        priceTimestamp: marketData.data?.timestamp,
        liquidity: {
          usd: metaData.data?.liquidity || marketData.data?.liquidity || 0
        },
        holderCount: metaData.data?.holder || 0,
        lastTradeTime: marketData.data?.lastTradeTime
      };
    }
    
    console.error('Invalid secondary data structure');
    return null;
  } catch (error) {
    console.error('Error fetching secondary data:', error);
    return null;
  }
}

const panels = [
  { id: 'price', title: 'Price', getValue: (data) => `$${parseFloat(data.priceUsd).toFixed(12)}`, source: 'primary' },
  { id: 'holders', title: 'Holders', getValue: (data) => {
    const count = data.holderCount || 0;
    return count.toLocaleString();
  }, source: 'secondary' },
  { id: 'liquidity', title: 'Liquidity', getValue: (data) => `$${parseInt(data.liquidity?.usd || 0).toLocaleString()}`, source: 'secondary' },
  { id: 'marketCap', title: 'Market Cap', getValue: (data) => `$${parseInt(data.fdv).toLocaleString()}`, source: 'primary' },
  { id: 'priceChange', title: '24h Change', getValue: (data) => `${parseFloat(data.priceChange.h24).toFixed(2)}%`, source: 'primary' },
  { id: 'lastTrade', title: 'Last Trade', getValue: (data) => {
    const timestamp = data.lastTradeTime;
    if (!timestamp) return 'N/A';
    const date = new Date(timestamp);
    const now = new Date();
    const diffSeconds = Math.floor((now - date) / 1000);
    if (diffSeconds < 60) return `${diffSeconds}s ago`;
    if (diffSeconds < 3600) return `${Math.floor(diffSeconds/60)}m ago`;
    return `${Math.floor(diffSeconds/3600)}h ago`;
  }, source: 'secondary' }
];

async function fetchTokenData() {
  try {
    const response = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${tokenAddress}`);
    const data = await response.json();
    if (data && data.pairs && data.pairs[0]) {
      console.log('Token data received:', data.pairs[0]); // Debug log
      return data.pairs[0];
    } else {
      console.error('Invalid data structure:', data);
      return null;
    }
  } catch (error) {
    console.error('Error fetching token data:', error);
    return null;
  }
}

function createPanel(panel) {
  const div = document.createElement('div');
  div.className = 'token-panel';
  div.id = `panel-${panel.id}`;
  div.setAttribute('data-panel-type', panel.id);
  div.innerHTML = `
    <h3>${panel.title}</h3>
    <div class="token-panel-content">
      <div class="token-value">Loading...</div>
      <div class="token-label">ADVAICED</div>
    </div>
    <div class="panel-updating"></div>
  `;
  return div;
}

function initializeTokenModal() {
  const modal = document.getElementById('tokenModal');
  panels.forEach(panel => {
    modal.appendChild(createPanel(panel));
  });
}

async function updateTokenData() {
  const [newData, newSecondaryData] = await Promise.all([
    fetchTokenData(),
    fetchSecondaryData()
  ]);

  if (!newData && !newSecondaryData) return;
  
  panels.forEach(panel => {
    try {
      let value;
      if (panel.source === 'primary' && newData) {
        value = panel.getValue(newData);
      } else if (panel.source === 'secondary' && newSecondaryData) {
        value = panel.getValue(newSecondaryData);
      } else {
        value = 'Loading...';
      }

      const panelElement = document.getElementById(`panel-${panel.id}`);
      if (panelElement) {
        const valueElement = panelElement.querySelector('.token-value');
        if (valueElement) {
          valueElement.textContent = value;
          animatePanel(panelElement);
        }
      }
    } catch (error) {
      console.error(`Error updating panel ${panel.id}:`, error);
    }
  });
}

function animatePanel(panelElement) {
  const animations = ['slideIn', 'popOut', 'flip', 'swap'];
  const randomAnimation = animations[Math.floor(Math.random() * animations.length)];
  
  panelElement.style.animation = `${randomAnimation} 0.5s ease-in-out`;
  setTimeout(() => {
    panelElement.style.animation = '';
  }, 500);
}

// Initialize and start updates
initializeTokenModal();
setInterval(updateTokenData, updateInterval);
updateTokenData(); // Initial update
</script>
</body>
</html>